import { sql } from "drizzle-orm";
import {
	boolean,
	integer,
	jsonb,
	pgEnum,
	pgTable,
	serial,
	text,
	timestamp,
} from "drizzle-orm/pg-core";

export const requirementPriorityValues = [
	"low",
	"medium",
	"high",
	"urgent",
] as const;
export const requirementPriorityEnum = pgEnum(
	"requirement_priority",
	requirementPriorityValues,
);

export const requirementStatusValues = [
	"intake",
	"design",
	"sourcing",
	"labeling",
	"qa",
	"completed",
	"blocked",
] as const;
export const requirementStatusEnum = pgEnum(
	"requirement_status",
	requirementStatusValues,
);

export const taskTypeValues = [
	"ingest",
	"caption",
	"tag",
	"qa",
	"distribution",
] as const;
export const taskTypeEnum = pgEnum("task_type", taskTypeValues);

export const taskStatusValues = [
	"queued",
	"running",
	"paused",
	"succeeded",
	"failed",
	"blocked",
] as const;
export const taskStatusEnum = pgEnum("task_status", taskStatusValues);

export const requirements = pgTable("requirements", {
	id: serial("id").primaryKey(),
	title: text("title").notNull(),
	description: text("description").notNull(),
	owner: text("owner").notNull(),
	team: text("team").notNull(),
	status: requirementStatusEnum("status").default("intake").notNull(),
	priority: requirementPriorityEnum("priority").default("medium").notNull(),
	expectedImages: integer("expected_images").notNull().default(0),
	aiCoverageTarget: integer("ai_coverage_target").notNull().default(80),
	riskLevel: text("risk_level").notNull().default("normal"),
	tagHints: text("tag_hints").array().notNull().default(sql`ARRAY[]::text[]`),
	briefUrl: text("brief_url"),
	dueDate: timestamp("due_date"),
	metadata: jsonb("metadata")
		.$type<Record<string, unknown>>()
		.notNull()
		.default(sql`'{}'::jsonb`),
	createdAt: timestamp("created_at").defaultNow().notNull(),
	updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const datasets = pgTable("datasets", {
	id: serial("id").primaryKey(),
	requirementId: integer("requirement_id")
		.notNull()
		.references(() => requirements.id, { onDelete: "cascade" }),
	name: text("name").notNull(),
	storageBucket: text("storage_bucket").notNull(),
	imageCount: integer("image_count").notNull().default(0),
	processedCount: integer("processed_count").notNull().default(0),
	pendingCount: integer("pending_count").notNull().default(0),
	aiCaptionCoverage: integer("ai_caption_coverage").notNull().default(0),
	autoTagCoverage: integer("auto_tag_coverage").notNull().default(0),
	reviewCoverage: integer("review_coverage").notNull().default(0),
	focusTags: text("focus_tags").array().notNull().default(sql`ARRAY[]::text[]`),
	lastRunAt: timestamp("last_run_at"),
	createdAt: timestamp("created_at").defaultNow().notNull(),
	updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const automationTasks = pgTable("automation_tasks", {
	id: serial("id").primaryKey(),
	datasetId: integer("dataset_id")
		.notNull()
		.references(() => datasets.id, { onDelete: "cascade" }),
	type: taskTypeEnum("type").notNull(),
	status: taskStatusEnum("status").notNull().default("queued"),
	progress: integer("progress").notNull().default(0),
	assignedTo: text("assigned_to"),
	failureReason: text("failure_reason"),
	metadata: jsonb("metadata")
		.$type<Record<string, unknown>>()
		.notNull()
		.default(sql`'{}'::jsonb`),
	startedAt: timestamp("started_at"),
	completedAt: timestamp("completed_at"),
	createdAt: timestamp("created_at").defaultNow().notNull(),
	updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const datasetTags = pgTable("dataset_tags", {
	id: serial("id").primaryKey(),
	datasetId: integer("dataset_id")
		.notNull()
		.references(() => datasets.id, { onDelete: "cascade" }),
	label: text("label").notNull(),
	autoGenerated: boolean("auto_generated").notNull().default(true),
	usageCount: integer("usage_count").notNull().default(0),
	coverage: integer("coverage").notNull().default(0),
	lastUsedAt: timestamp("last_used_at"),
});

export const mediaStatusValues = [
	"pending_upload",
	"uploading",
	"uploaded",
	"processing",
	"ready",
	"failed",
] as const;
export const mediaStatusEnum = pgEnum("media_status", mediaStatusValues);

export const mediaAssets = pgTable("media_assets", {
	id: serial("id").primaryKey(),
	datasetId: integer("dataset_id")
		.notNull()
		.references(() => datasets.id, { onDelete: "cascade" }),
	requirementId: integer("requirement_id").references(() => requirements.id, {
		onDelete: "set null",
	}),
	originalName: text("original_name").notNull(),
	mimeType: text("mime_type").notNull(),
	size: integer("size").notNull().default(0),
	width: integer("width"),
	height: integer("height"),
	storageBucket: text("storage_bucket").notNull(),
	storageKey: text("storage_key").notNull(),
	publicUrl: text("public_url"),
	checksum: text("checksum"),
	status: mediaStatusEnum("status").notNull().default("pending_upload"),
	uploadedAt: timestamp("uploaded_at"),
	metadata: jsonb("metadata")
		.$type<Record<string, unknown>>()
		.notNull()
		.default(sql`'{}'::jsonb`),
	createdAt: timestamp("created_at").defaultNow().notNull(),
	updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const captionStatusValues = [
	"pending",
	"processing",
	"completed",
	"approved",
	"rejected",
] as const;
export const captionStatusEnum = pgEnum("caption_status", captionStatusValues);

export const promptTemplates = pgTable("prompt_templates", {
	id: serial("id").primaryKey(),
	name: text("name").notNull(),
	description: text("description"),
	systemPrompt: text("system_prompt").notNull(),
	userPromptTemplate: text("user_prompt_template").notNull(),
	model: text("model").notNull().default("gpt-4o"),
	temperature: integer("temperature").notNull().default(70), // stored as 0-100, divide by 100 for API
	maxTokens: integer("max_tokens").notNull().default(300),
	isDefault: boolean("is_default").notNull().default(false),
	isActive: boolean("is_active").notNull().default(true),
	createdAt: timestamp("created_at").defaultNow().notNull(),
	updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const captions = pgTable("captions", {
	id: serial("id").primaryKey(),
	mediaAssetId: integer("media_asset_id")
		.notNull()
		.references(() => mediaAssets.id, { onDelete: "cascade" }),
	promptTemplateId: integer("prompt_template_id").references(
		() => promptTemplates.id,
		{ onDelete: "set null" },
	),
	status: captionStatusEnum("status").notNull().default("pending"),
	aiCaption: text("ai_caption"),
	manualCaption: text("manual_caption"),
	finalCaption: text("final_caption"),
	model: text("model"),
	confidence: integer("confidence"), // 0-100 confidence score from AI
	tokensUsed: integer("tokens_used"),
	generatedAt: timestamp("generated_at"),
	approvedAt: timestamp("approved_at"),
	approvedBy: text("approved_by"),
	rejectionReason: text("rejection_reason"),
	reviewedBy: text("reviewed_by"),
	reviewedAt: timestamp("reviewed_at"),
	processingError: text("processing_error"),
	metadata: jsonb("metadata")
		.$type<Record<string, unknown>>()
		.notNull()
		.default(sql`'{}'::jsonb`),
	createdAt: timestamp("created_at").defaultNow().notNull(),
	updatedAt: timestamp("updated_at").defaultNow().notNull(),
});
