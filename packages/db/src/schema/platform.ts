import {
	boolean,
	integer,
	jsonb,
	pgEnum,
	pgTable,
	serial,
	text,
	timestamp,
} from "drizzle-orm/pg-core";
import { sql } from "drizzle-orm";

export const requirementPriorityValues = ["low", "medium", "high", "urgent"] as const;
export const requirementPriorityEnum = pgEnum(
	"requirement_priority",
	requirementPriorityValues,
);

export const requirementStatusValues = [
	"intake",
	"design",
	"sourcing",
	"labeling",
	"qa",
	"completed",
	"blocked",
] as const;
export const requirementStatusEnum = pgEnum(
	"requirement_status",
	requirementStatusValues,
);

export const taskTypeValues = [
	"ingest",
	"caption",
	"tag",
	"qa",
	"distribution",
] as const;
export const taskTypeEnum = pgEnum("task_type", taskTypeValues);

export const taskStatusValues = [
	"queued",
	"running",
	"paused",
	"succeeded",
	"failed",
	"blocked",
] as const;
export const taskStatusEnum = pgEnum("task_status", taskStatusValues);

export const requirements = pgTable("requirements", {
	id: serial("id").primaryKey(),
	title: text("title").notNull(),
	description: text("description").notNull(),
	owner: text("owner").notNull(),
	team: text("team").notNull(),
	status: requirementStatusEnum("status").default("intake").notNull(),
	priority: requirementPriorityEnum("priority").default("medium").notNull(),
	expectedImages: integer("expected_images").notNull().default(0),
	aiCoverageTarget: integer("ai_coverage_target").notNull().default(80),
	riskLevel: text("risk_level").notNull().default("normal"),
	tagHints: text("tag_hints")
		.array()
		.notNull()
		.default(sql`ARRAY[]::text[]`),
	briefUrl: text("brief_url"),
	dueDate: timestamp("due_date"),
	metadata: jsonb("metadata")
		.$type<Record<string, unknown>>()
		.notNull()
		.default(sql`'{}'::jsonb`),
	createdAt: timestamp("created_at").defaultNow().notNull(),
	updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const datasets = pgTable("datasets", {
	id: serial("id").primaryKey(),
	requirementId: integer("requirement_id")
		.notNull()
		.references(() => requirements.id, { onDelete: "cascade" }),
	name: text("name").notNull(),
	storageBucket: text("storage_bucket").notNull(),
	imageCount: integer("image_count").notNull().default(0),
	processedCount: integer("processed_count").notNull().default(0),
	pendingCount: integer("pending_count").notNull().default(0),
	aiCaptionCoverage: integer("ai_caption_coverage").notNull().default(0),
	autoTagCoverage: integer("auto_tag_coverage").notNull().default(0),
	reviewCoverage: integer("review_coverage").notNull().default(0),
	focusTags: text("focus_tags")
		.array()
		.notNull()
		.default(sql`ARRAY[]::text[]`),
	lastRunAt: timestamp("last_run_at"),
	createdAt: timestamp("created_at").defaultNow().notNull(),
	updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const automationTasks = pgTable("automation_tasks", {
	id: serial("id").primaryKey(),
	datasetId: integer("dataset_id")
		.notNull()
		.references(() => datasets.id, { onDelete: "cascade" }),
	type: taskTypeEnum("type").notNull(),
	status: taskStatusEnum("status").notNull().default("queued"),
	progress: integer("progress").notNull().default(0),
	assignedTo: text("assigned_to"),
	failureReason: text("failure_reason"),
	metadata: jsonb("metadata")
		.$type<Record<string, unknown>>()
		.notNull()
		.default(sql`'{}'::jsonb`),
	startedAt: timestamp("started_at"),
	completedAt: timestamp("completed_at"),
	createdAt: timestamp("created_at").defaultNow().notNull(),
	updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const datasetTags = pgTable("dataset_tags", {
	id: serial("id").primaryKey(),
	datasetId: integer("dataset_id")
		.notNull()
		.references(() => datasets.id, { onDelete: "cascade" }),
	label: text("label").notNull(),
	autoGenerated: boolean("auto_generated").notNull().default(true),
	usageCount: integer("usage_count").notNull().default(0),
	coverage: integer("coverage").notNull().default(0),
	lastUsedAt: timestamp("last_used_at"),
});

export const mediaStatusValues = [
	"pending_upload",
	"uploading",
	"uploaded",
	"processing",
	"ready",
	"failed",
] as const;
export const mediaStatusEnum = pgEnum("media_status", mediaStatusValues);

export const mediaAssets = pgTable("media_assets", {
	id: serial("id").primaryKey(),
	datasetId: integer("dataset_id")
		.notNull()
		.references(() => datasets.id, { onDelete: "cascade" }),
	requirementId: integer("requirement_id").references(() => requirements.id, {
		onDelete: "set null",
	}),
	originalName: text("original_name").notNull(),
	mimeType: text("mime_type").notNull(),
	size: integer("size").notNull().default(0),
	width: integer("width"),
	height: integer("height"),
	storageBucket: text("storage_bucket").notNull(),
	storageKey: text("storage_key").notNull(),
	publicUrl: text("public_url"),
	checksum: text("checksum"),
	status: mediaStatusEnum("status").notNull().default("pending_upload"),
	uploadedAt: timestamp("uploaded_at"),
	metadata: jsonb("metadata")
		.$type<Record<string, unknown>>()
		.notNull()
		.default(sql`'{}'::jsonb`),
	createdAt: timestamp("created_at").defaultNow().notNull(),
	updatedAt: timestamp("updated_at").defaultNow().notNull(),
});
