import { db } from "@cyop/db";
import { datasetTags, datasets, requirements } from "@cyop/db/schema/platform";
import { desc, eq } from "drizzle-orm";
import z from "zod";

import { router, publicProcedure } from "../index";

const baseTagInput = z.object({
	datasetId: z.number().int().positive(),
	label: z.string().min(1),
	autoGenerated: z.boolean().default(true),
	usageCount: z.number().int().nonnegative().default(0),
	coverage: z.number().int().min(0).max(100).default(0),
});

export const tagsRouter = router({
	list: publicProcedure.query(async () => {
		const rows = await db
			.select({
				tag: datasetTags,
				dataset: datasets,
				requirement: requirements,
			})
			.from(datasetTags)
			.leftJoin(datasets, eq(datasetTags.datasetId, datasets.id))
			.leftJoin(requirements, eq(datasets.requirementId, requirements.id))
			.orderBy(desc(datasetTags.lastUsedAt), desc(datasetTags.id));

		return rows.map(({ tag, dataset, requirement }) => ({
			...tag,
			dataset,
			requirement,
		}));
	}),

	create: publicProcedure.input(baseTagInput).mutation(async ({ input }) => {
		const [record] = await db
			.insert(datasetTags)
			.values({
				datasetId: input.datasetId,
				label: input.label,
				autoGenerated: input.autoGenerated,
				usageCount: input.usageCount,
				coverage: input.coverage,
				lastUsedAt: new Date(),
			})
			.returning();
		return record;
	}),

	updateCoverage: publicProcedure
		.input(
			z.object({
				id: z.number().int().positive(),
				usageCount: z.number().int().nonnegative().optional(),
				coverage: z.number().int().min(0).max(100),
			}),
		)
		.mutation(async ({ input }) => {
			const updates: Record<string, unknown> = {
				coverage: input.coverage,
				lastUsedAt: new Date(),
			};
			if (typeof input.usageCount !== "undefined") {
				updates.usageCount = input.usageCount;
			}
			const [record] = await db
				.update(datasetTags)
				.set(updates)
				.where(eq(datasetTags.id, input.id))
				.returning();
			return record;
		}),
});
